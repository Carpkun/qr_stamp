### **소양강문화제 QR 스탬프 투어 시스템: 최종 실행 계획서**

### **1\. 시스템 목표 및 핵심 기능**

이 시스템은 단순한 기술 도입을 넘어, 축제 경험의 질을 향상시키고 운영의 효율성을 높이는 것을 목표로 합니다.

#### **가. 시스템 목표**

* **참여도 극대화**: 관람객들이 수동적으로 부스를 구경하는 것을 넘어, 스탬프 투어라는 게임적 요소를 통해 **능동적으로 16개 체험부스를 모두 찾아다니도록 유도**합니다.  
* **축제 활성화**: 특정 구역에만 관람객이 몰리는 현상을 완화하고, 축제장 전반에 걸쳐 사람들의 발길이 이어지게 하여 **균형 있는 활기**를 만듭니다.  
* **데이터 기반 운영**: 어떤 부스가 인기가 많은지, 시간대별 참여율은 어떤지 등 **객관적인 데이터를 실시간으로 확보**하여 내년 축제 기획을 위한 귀중한 자산으로 활용합니다.  
* **긍정적 경험 제공**: 로그인이나 앱 설치 같은 번거로움 없이, QR 스캔만으로 참여할 수 있는 **매끄러운 디지털 경험**을 통해 축제에 대한 긍정적 이미지를 제고합니다.

#### **나. 핵심 기능**

* **QR코드 참여 인증**: 각 부스의 고유 QR코드를 스캔하는 것만으로 참여가 완료되는 직관적인 방식을 제공합니다.  
* **실시간 스탬프 누적**: 참여자가 방문한 부스의 개수가 스마트폰 화면에 실시간으로 "3 / 5개 완료\!"와 같이 시각적으로 표시됩니다.  
* **기념품 수령 자격 부여**: 서로 다른 5개 부스 참여 조건을 달성하면, 화면이 "미션 완료\! 기념품을 수령하세요\!"와 같은 축하 메시지로 변경되어 수령 자격을 증명합니다.  
* **실시간 통계 대시보드**: 운영진은 별도의 관리자 페이지를 통해 총 참여자 수, 부스별 인기도 순위, 기념품 수령 현황 등을 실시간으로 모니터링할 수 있습니다.

---

### **2\. 시스템 동작 로직**

사용자가 첫 QR코드를 스캔하는 순간부터 기념품을 받기까지의 모든 과정은 아래와 같은 흐름으로 자동 처리됩니다.

1. **첫 번째 스캔 (디지털 명찰 발급)**  
   * 춘천시민 A씨가 '부스 1'에서 QR코드를 스캔합니다.  
   * A씨의 스마트폰 브라우저에 React로 만들어진 웹페이지가 열립니다.  
   * 웹페이지는 "이 분의 디지털 명찰(고유 ID)이 있나?" 하고 브라우저 저장소(localStorage)를 확인합니다. → **없음**  
   * 웹페이지는 즉시 Django 백엔드 서버에 "새로운 손님입니다. 명찰 하나 만들어주세요."라고 요청합니다.  
   * Django 서버는 세상에 하나뿐인 고유 ID(UUID)를 생성하여 웹페이지에 전달하고, 이 ID를 데이터베이스에 '새로운 참여자'로 기록합니다.  
   * 웹페이지는 전달받은 고유 ID를 A씨의 브라우저 저장소에 '디지털 명찰'로 보관합니다.  
   * 마지막으로 "A씨가 '부스 1'에 방문했다"는 기록을 서버에 전송하고, 화면에는 **"1 / 5개 완료\!"** 라고 표시합니다.  
2. **두 번째 스캔 (참여 기록 누적)**  
   * A씨가 '부스 2'로 이동하여 QR코드를 스캔합니다.  
   * 웹페이지는 다시 "디지털 명찰이 있나?" 하고 저장소를 확인합니다. → **있음\!**  
   * 웹페이지는 보관 중이던 A씨의 명찰을 가지고 "A씨가 '부스 2'에 방문했다"고 서버에 전송합니다.  
   * 서버는 A씨의 참여 기록을 추가하고, 화면에는 **"2 / 5개 완료\!"** 라고 업데이트해줍니다.  
3. **중복 스캔 (자동 방지)**  
   * A씨가 실수로 '부스 2'를 또 스캔합니다.  
   * 웹페이지는 이전과 같이 "A씨가 '부스 2'에 방문했다"고 서버에 전송합니다.  
   * 하지만 서버의 데이터베이스에는 "한 사람은 같은 부스에 한 번만 기록될 수 있다"는 \*\*엄격한 규칙(unique\_together)\*\*이 설정되어 있어, 이 중복 기록을 **자동으로 거부**합니다.  
   * 따라서 카운트는 오르지 않고, 화면은 여전히 "2 / 5개 완료\!"로 유지됩니다.  
4. **미션 완료 (기념품 수령)**  
   * A씨가 5번째 각기 다른 부스를 방문하여 QR을 스캔합니다.  
   * 서버는 A씨의 5번째 참여 기록을 저장하고, "드디어 5개를 모두 모았다\!"는 사실을 인지합니다.  
   * 서버는 웹페이지에 "미션 완료\!" 신호를 보냅니다.  
   * A씨의 스마트폰 화면은 폭죽이 터지는 등 축하 애니메이션과 함께 **"축하합니다\! 운영 본부에서 기념품을 수령하세요\!"** 라는 화면으로 바뀝니다.  
   * A씨는 이 화면을 운영 본부 직원에게 보여주고 기념품을 수령하며 즐거운 경험을 마무리합니다.

---

### **3\. 개발 및 운영 방안**

* **로컬 개발 환경**:  
  * 개발용 PC에 **GitHub 저장소**를 복제하여 작업 폴더를 만듭니다.  
  * 백엔드(Django) 개발에 필요한 **가상 환경 설정 및 라이브러리를 설치**합니다. 특히 Django와 **MySQL**을 연결하기 위한 mysqlclient 라이브러리를 설치합니다.  
  * 개발용 비밀 키, DB 정보 등은 **.env 파일**로 안전하게 관리합니다.  
* **개발 및 버전 관리**:  
  * 로컬 PC에서 백엔드와 프론트엔드 서버를 동시에 실행하며 기능을 개발하고 테스트합니다.  
  * 기능 개발이 완료되면, 변경된 코드에 설명을 붙여 **GitHub에 커밋 및 푸시**하여 작업 내역을 안전하게 기록하고 관리합니다.  
* **배포 및 실제 운영**:  
  * **백엔드(Django)**: **PythonAnywhere**에 코드를 올리고, 실제 운영에 사용할 데이터베이스(**MySQL**)와 보안 키 등의 환경 변수를 설정한 후 서버를 인터넷에 공개합니다. PythonAnywhere 대시보드의 'Databases' 탭에서 **MySQL 데이터베이스를 생성**하고 관련 접속 정보를 확인합니다.  
  * **프론트엔드(React)**: **Vercel**에 GitHub 저장소를 연결합니다. Vercel 대시보드에서 백엔드 서버의 주소를 환경 변수로 설정하면, 이후 GitHub에 코드를 푸시할 때마다 자동으로 최신 버전의 웹사이트가 배포됩니다.  
  * **최종 실행**: 배포된 Vercel 주소를 기반으로 **최종 QR코드를 제작**하여 각 부스에 비치합니다.